import streamlit as st
import pandas as pd
import plotly.express as px
from math import sqrt
import io
from sklearn.linear_model import LinearRegression
from sklearn.ensemble import RandomForestRegressor
from sklearn.model_selection import train_test_split
from sklearn.metrics import r2_score, mean_absolute_error, mean_squared_error

# PDF option (need fpdf)
try:
    from fpdf import FPDF
    has_fpdf = True
except ImportError:
    has_fpdf = False

st.set_page_config(page_title="Mod√©lisation R√©gression", layout="wide")

# Titre de l'application
st.title("üìà Application de Mod√©lisation de R√©gression")

# Upload du fichier Excel
uploaded_file = st.file_uploader("üì§ Charger un fichier Excel", type=["xlsx"])

if uploaded_file:
    df = pd.read_excel(uploaded_file)
    st.subheader("Aper√ßu du fichier charg√© :")
    st.dataframe(df.head())

    # üîé Zone de filtre
    st.sidebar.header("üß∞ Filtrage des donn√©es")
    filtre_colonne = st.sidebar.selectbox("Choisir une colonne pour filtrer :", options=["-- Aucun filtre --"] + df.columns.tolist())

    if filtre_colonne != "-- Aucun filtre --":
        unique_values = df[filtre_colonne].dropna().unique().tolist()
        selected_value = st.sidebar.selectbox(f"Valeur de '{filtre_colonne}' √† filtrer :", unique_values)
        df = df[df[filtre_colonne] == selected_value]

    # Choix des colonnes pour X et Y
    colonnes = df.columns.tolist()
    st.sidebar.header("üîß S√©lection des variables")
    x_cols = st.sidebar.multiselect("Variables explicatives (X)", colonnes)
    numeric_columns = df.select_dtypes(include='number').columns.tolist()
    y_col = st.sidebar.selectbox("Variable √† pr√©dire (Y)", numeric_columns)

    if x_cols and y_col:
        # Nettoyage des donn√©es
        data = df[x_cols + [y_col]].dropna()
        X = data[x_cols]
        y = data[y_col]

        if not pd.api.types.is_numeric_dtype(y):
            st.error(f"‚ùå La variable √† pr√©dire '{y_col}' n'est pas num√©rique.")
        else:
            # Choix du mod√®le
            model_choice = st.sidebar.selectbox("Choisir le mod√®le :", ["R√©gression Lin√©aire", "Random Forest"])

            # Split des donn√©es
            X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

            # Cr√©ation du mod√®le
            if model_choice == "R√©gression Lin√©aire":
                model = LinearRegression()
            else:
                model = RandomForestRegressor(n_estimators=100, random_state=42)

            model.fit(X_train, y_train)
            y_pred = model.predict(X_test)

            # R√©sultats
            r2 = r2_score(y_test, y_pred)
            mae = mean_absolute_error(y_test, y_pred)
            rmse = sqrt(mean_squared_error(y_test, y_pred))  # Remplace squared=False

            st.subheader("üìä R√©sultats du Mod√®le")
            st.write(f"**R¬≤ Score** : {r2:.3f}")
            st.write(f"**MAE** (Erreur Absolue Moyenne) : {mae:.3f}")
            st.write(f"**RMSE** (Erreur Quadratique Moyenne) : {rmse:.3f}")

            # üìê Affichage de l'√©quation (pour R√©gression Lin√©aire uniquement)
            if model_choice == "R√©gression Lin√©aire":
                coefficients = model.coef_
                intercept = model.intercept_
                equation = f"{y_col} = " + " + ".join(
                    [f"{coef:.3f} * {col}" for coef, col in zip(coefficients, x_cols)]
                ) + f" + {intercept:.3f}"

                st.markdown("### üìê √âquation de la R√©gression Lin√©aire")
                st.code(equation, language="python")

                # üìÑ T√©l√©charger l'√©quation en TXT
                equation_txt = f"√âquation de la R√©gression Lin√©aire\n\n{equation}"
                txt_buffer = io.StringIO()
                txt_buffer.write(equation_txt)

                st.download_button(
                    label="üìÑ T√©l√©charger l'√©quation (.txt)",
                    data=txt_buffer.getvalue(),
                    file_name="equation_regression.txt",
                    mime="text/plain"
                )

                # üìÑ T√©l√©charger l'√©quation en PDF (si disponible)
                if has_fpdf:
                    pdf = FPDF()
                    pdf.add_page()
                    pdf.set_font("Arial", size=12)
                    pdf.multi_cell(0, 10, equation_txt)
                    pdf_buffer = io.BytesIO()
                    pdf.output(pdf_buffer)
                    pdf_buffer.seek(0)

                    st.download_button(
                        label="üìÑ T√©l√©charger l'√©quation (.pdf)",
                        data=pdf_buffer,
                        file_name="equation_regression.pdf",
                        mime="application/pdf"
                    )
                else:
                    st.info("üìé Pour activer le t√©l√©chargement en PDF, ajoute `fpdf` dans ton fichier requirements.txt.")

            # üìâ Visualisation dynamique avec Plotly
            st.subheader("üìâ Graphique dynamique des pr√©dictions")
            results_df = pd.DataFrame({
                "Valeur R√©elle": y_test,
                "Valeur Pr√©dite": y_pred
            })

            fig = px.scatter(
                results_df,
                x="Valeur R√©elle",
                y="Valeur Pr√©dite",
                title="R√©el vs Pr√©dit",
                labels={"Valeur R√©elle": "CR R√©el", "Valeur Pr√©dite": "CR Pr√©dit"}
            )
            fig.update_layout(
                legend_title_text="L√©gende",
                showlegend=True
            )
            st.plotly_chart(fig, use_container_width=True)
